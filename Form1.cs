using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Windows.Forms;

namespace JointTorqueVisualizer
{
    public partial class Form1 : Form
    {
        // Lists to store torque values, joint angles (thetas), and calculated joint positions
        private List<float> torques = new List<float>();
        private List<float> thetas = new List<float>();
        private List<PointF> jointPositions = new List<PointF>();

        // Timer for animation
        private Timer animationTimer;
        // Progress of the animation (0.0 to 1.0)
        private float animationProgress = 0f;
        // Flag to indicate if animation is playing
        private bool isPlaying = false;

        // Number of joints in the robotic arm
        private int jointCount = 0;
        // Payload carried by the robotic arm, affecting torque calculation
        private float payload = 1f;

        public Form1()
        {
            InitializeComponent(); // Initializes components generated by the designer
            InitializeAnimation(); // Sets up the animation timer

            // Explicitly set the maximum value for the joint count NumericUpDown to 6.
            // This ensures the joint count is strictly limited as requested.
            this.numericUpDownJointCount.Maximum = 6;
        }

        /// <summary>
        /// Initializes the animation timer.
        /// </summary>
        private void InitializeAnimation()
        {
            animationTimer = new Timer();
            animationTimer.Interval = 50; // Set timer interval to 50 milliseconds
            animationTimer.Tick += AnimationTimer_Tick; // Assign the event handler for each tick
        }

        /// <summary>
        /// Handles the ValueChanged event of the numericUpDownJointCount control.
        /// Updates the number of joints and dynamically creates input fields for angles.
        /// </summary>
        private void numericUpDownJointCount_ValueChanged(object sender, EventArgs e)
        {
            jointCount = (int)numericUpDownJointCount.Value; // Get current joint count
            flowLayoutThetaInputs.Controls.Clear(); // Clear existing angle input controls
            thetas.Clear(); // Clear existing angle values

            // Create NumericUpDown controls for each joint angle
            for (int i = 0; i < jointCount; i++)
            {
                var nud = new NumericUpDown
                {
                    Minimum = -180, // Angle range from -180 to 180 degrees
                    Maximum = 180,
                    DecimalPlaces = 1, // One decimal place for precision
                    Width = 60,
                    Tag = i // Store the index of the joint in the Tag property
                };
                nud.ValueChanged += ThetaInput_ValueChanged; // Attach event handler
                flowLayoutThetaInputs.Controls.Add(nud); // Add to the flow layout panel
                thetas.Add(0); // Initialize angle to 0
            }
            UpdateTorqueGraphAndAnimation(); // Recalculate and redraw
        }

        /// <summary>
        /// Handles the ValueChanged event for individual joint angle NumericUpDown controls.
        /// Updates the corresponding angle in the 'thetas' list.
        /// </summary>
        private void ThetaInput_ValueChanged(object sender, EventArgs e)
        {
            var nud = sender as NumericUpDown;
            int index = (int)nud.Tag; // Get the joint index
            thetas[index] = (float)nud.Value; // Update the angle value
            UpdateTorqueGraphAndAnimation(); // Recalculate and redraw
        }

        /// <summary>
        /// Handles the ValueChanged event of the numericUpDownPayload control.
        /// Updates the payload value.
        /// </summary>
        private void numericUpDownPayload_ValueChanged(object sender, EventArgs e)
        {
            payload = (float)numericUpDownPayload.Value; // Get current payload value
            UpdateTorqueGraphAndAnimation(); // Recalculate and redraw
        }

        /// <summary>
        /// Recalculates torques, resets animation progress, and invalidates panels for redraw.
        /// </summary>
        private void UpdateTorqueGraphAndAnimation()
        {
            torques.Clear(); // Clear existing torque values
            float baseTorque = 10f * payload; // Base torque influenced by payload

            // Calculate torque for each joint (simple model: proportional to sin of angle)
            for (int i = 0; i < thetas.Count; i++)
            {
                float torque = baseTorque * (float)Math.Abs(Math.Sin(thetas[i] * Math.PI / 180));
                torques.Add(torque);
            }
            animationProgress = 0f; // Reset animation progress
            panelAnimation.Invalidate(); // Request redraw for animation panel
            panelTorqueGraph.Invalidate(); // Request redraw for torque graph panel
        }

        /// <summary>
        /// Handles the Click event of the Play button. Starts the animation.
        /// </summary>
        private void buttonPlay_Click(object sender, EventArgs e)
        {
            isPlaying = true; // Set playing flag
            animationTimer.Start(); // Start the timer
        }

        /// <summary>
        /// Handles the Click event of the Pause button. Pauses the animation.
        /// </summary>
        private void buttonPause_Click(object sender, EventArgs e)
        {
            isPlaying = false; // Clear playing flag
            animationTimer.Stop(); // Stop the timer
        }

        /// <summary>
        /// Handles the Click event of the Stop button. Stops and resets the animation.
        /// </summary>
        private void buttonStop_Click(object sender, EventArgs e)
        {
            isPlaying = false; // Clear playing flag
            animationTimer.Stop(); // Stop the timer
            animationProgress = 0f; // Reset animation progress
            panelAnimation.Invalidate(); // Request redraw to show reset state
        }

        /// <summary>
        /// Handles each tick of the animation timer. Updates animation progress and redraws.
        /// </summary>
        private void AnimationTimer_Tick(object sender, EventArgs e)
        {
            animationProgress += 0.05f; // Increment animation progress
            if (animationProgress > 1f) // If animation completed
            {
                animationProgress = 1f; // Cap at 1.0
                animationTimer.Stop(); // Stop the timer
                isPlaying = false; // Set playing flag to false
            }
            panelAnimation.Invalidate(); // Request redraw for the animation panel
        }

        /// <summary>
        /// Handles the Paint event of the panelAnimation. Draws the robotic arm.
        /// </summary>
        private void panelAnimation_Paint(object sender, PaintEventArgs e)
        {
            Graphics g = e.Graphics;
            g.SmoothingMode = System.Drawing.Drawing2D.SmoothingMode.AntiAlias; // Enable anti-aliasing for smooth lines
            g.Clear(Color.White); // Clear background to white

            // Set the origin of the robotic arm to the center of the panel
            PointF origin = new PointF(panelAnimation.Width / 2, panelAnimation.Height / 2);
            jointPositions.Clear(); // Clear previous joint positions
            jointPositions.Add(origin); // Add the base origin

            float length = 50; // Length of each arm segment
            float angleSum = 0; // Cumulative angle for drawing

            // Draw each joint segment
            for (int i = 0; i < thetas.Count; i++)
            {
                // Apply animation progress to the angle
                angleSum += thetas[i] * animationProgress;
                float radians = angleSum * (float)Math.PI / 180; // Convert degrees to radians

                PointF last = jointPositions[jointPositions.Count - 1]; // Get the previous joint position
                // Calculate the next joint position based on angle and length
                PointF next = new PointF(
                    last.X + length * (float)Math.Cos(radians),
                    last.Y - length * (float)Math.Sin(radians)); // Y-axis is inverted in GDI+

                // Get color based on torque (heat map effect)
                Color heatColor = GetHeatColor(torques[i]);
                using (Pen pen = new Pen(heatColor, 4)) // Draw arm segment with heat color
                {
                    g.DrawLine(pen, last, next);
                }

                using (Brush brush = new SolidBrush(Color.Black)) // Draw joint circle
                {
                    g.FillEllipse(brush, last.X - 3, last.Y - 3, 6, 6);
                }

                // Display angle and torque values near the joint
                g.DrawString($"θ{i + 1}: {thetas[i]:F1}°\nT{i + 1}: {torques[i]:F2} Nm",
                    new Font("Arial", 8), Brushes.Black, next);

                jointPositions.Add(next); // Add the new joint position
            }
        }

        /// <summary>
        /// Handles the Paint event of the panelTorqueGraph. Draws the torque bar graph.
        /// </summary>
        private void panelTorqueGraph_Paint(object sender, PaintEventArgs e)
        {
            Graphics g = e.Graphics;
            g.Clear(Color.White); // Clear background to white

            // Calculate bar width based on number of torques
            float barWidth = panelTorqueGraph.Width / (float)torques.Count;
            // Determine maximum torque for scaling the graph, ensuring at least 10 Nm
            float maxTorque = Math.Max(1f, torques.Count > 0 ? Math.Max(10, (float)Math.Ceiling(torques.Max())) : 10);

            // Draw each torque bar
            for (int i = 0; i < torques.Count; i++)
            {
                float height = (torques[i] / maxTorque) * panelTorqueGraph.Height; // Calculate bar height
                RectangleF rect = new RectangleF(i * barWidth, panelTorqueGraph.Height - height, barWidth - 4, height);
                Color color = GetHeatColor(torques[i]); // Get color based on torque value
                using (Brush brush = new SolidBrush(color))
                {
                    g.FillRectangle(brush, rect); // Fill the bar
                }
                // Display torque value on top of the bar
                g.DrawString($"{torques[i]:F1}", new Font("Arial", 8), Brushes.Black, rect.X, rect.Y - 14);
            }

            // Draw Y-axis grid lines and labels
            for (int i = 0; i <= 5; i++)
            {
                float y = panelTorqueGraph.Height * (1 - i / 5f); // Calculate Y position for grid line
                g.DrawLine(Pens.Gray, 0, y, panelTorqueGraph.Width, y); // Draw grid line
                // Draw torque value label for the grid line
                g.DrawString($"{(maxTorque * i / 5f):F1}", new Font("Arial", 7), Brushes.Black, 0, y - 8);
            }
        }

        /// <summary>
        /// Calculates a heat map color based on the torque value using a green-yellow-red gradient.
        /// Low torque is green, medium is yellow, high is red.
        /// </summary>
        /// <param name="torque">The torque value.</param>
        /// <returns>A Color object representing the heat.</returns>
        private Color GetHeatColor(float torque)
        {
            // The maximum possible torque for a single joint is 10 * payload (when sin(angle) is 1).
            // Using this as the max for color scaling ensures the full gradient is utilized.
            float maxTorque = 10f * payload;
            float ratio = Math.Min(1f, torque / maxTorque); // Normalize torque to a 0-1 ratio

            // Interpolate between colors: Green (0) -> Yellow (0.5) -> Red (1)
            int r = 0;
            int g = 0;
            int b = 0;

            if (ratio < 0.5f)
            {
                // Green to Yellow transition (0 to 0.5)
                // Red increases from 0 to 255
                // Green stays at 255
                r = (int)(255 * (ratio / 0.5f));
                g = 255;
            }
            else
            {
                // Yellow to Red transition (0.5 to 1)
                // Red stays at 255
                // Green decreases from 255 to 0
                r = 255;
                g = (int)(255 * (1 - (ratio - 0.5f) / 0.5f));
            }

            return Color.FromArgb(r, g, b); // Return the calculated color
        }
    }
}
